<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Curated Tours</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            plaque: {
              blue: '#1e3a8a',
              gold: '#fbbf24',
              light: '#eff6ff',
            }
          },
          animation: {
            'bounce-short': 'bounce 1s infinite 2',
          }
        }
      }
    }
  </script>
  <style>
    /* Custom scrollbar for cleanliness */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    ::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #999;
    }
  </style>
</head>

<body class="bg-gray-50 text-gray-900 font-sans antialiased min-h-screen pb-10">

  <!-- Header Section -->
  <header class="bg-white shadow-sm relative z-20 pt-6">
    <div class="max-w-2xl mx-auto px-4 pb-4 flex items-center justify-between">
      <!-- Left spacer (keeps logo centred vs heart icon) -->
      <div class="w-8"></div>

      <!-- Centre logo + tagline -->
      <div class="flex-1 flex flex-col items-center cursor-pointer" onclick="app.goHome()">
        <img src="https://raw.githubusercontent.com/jameswroberts1-sketch/Curated-Tours/refs/heads/main/Logo.jpg"
          alt="Curated Tours logo" class="h-32 w-auto object-contain" onerror="this.style.display='none';">
        <!-- Keep the tagline for now -->
        <p class="text-sm text-gray-500 mt-2">
          Sifting city streets for ghosts
        </p>
      </div>

      <!-- Right Action (Favorites) -->
      <div class="w-8 flex justify-end z-10">
        <button onclick="app.goFavorites()" class="p-2 text-gray-500 hover:text-red-500 transition-colors"
          aria-label="Favorites">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
            stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12Z" />
          </svg>
        </button>
      </div>
    </div>
  </header>

  <!-- Main App Container -->
  <main id="app" class="max-w-2xl mx-auto px-4 pt-0 pb-6">
    <!-- Dynamic Content Rendered Here -->
  </main>

  <!-- Bottom Navigation (filled by JS) -->
  <nav id="bottom-nav" class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200
                shadow-[0_-4px_10px_rgba(0,0,0,0.04)] z-30">
  </nav>

  <!-- JavaScript Logic -->
  <script>
    // --- Constants ---
    const CITIES = [
      {
        name: 'Collections',
        url: 'https://raw.githubusercontent.com/jameswroberts1-sketch/Curated-Tours/refs/heads/main/Collections.json',
        defaultLat: 51.5074,
        defaultLng: -0.1278,
        exampleAddress: 'Camden or Marylebone etc.'
      }
      //{
      //    name: 'Manchester',
      //    url: 'https://raw.githubusercontent.com/jameswroberts1-sketch/PlaqueLark/refs/heads/main/Manchester.json',
      //    defaultLat: 53.4808,
      //    defaultLng: -2.2426,
      //    exampleAddress: "St Peter's Square"
      //}
    ];
    const STORAGE_KEY = 'collections_saved_tours';
    const MAX_TOUR_SIZE = 10;
    const AUDIO_UNLOCK_DISTANCE = 0.02; // ~30 metres in miles
    const ARRIVAL_DISTANCE_MILES = 0.003;
    const PRICE_BASE = 1.99;       // £ base
    const PRICE_PER_STOP = 0.50;   // £ per stop

    // --- State ---
    const state = {
      view: 'HOME', // HOME, PREVIEW, TOUR, FAVORITES, COLOURS, GUIDE
      loading: false,
      error: null,

      cityIndex: 0,          // still used for the single Collections.json entry
      selectedCity: '',      // NEW: city chosen from `area`

      locationMethod: 'GPS',
      manualAddress: '',
      radius: 1,
      stops: 5,

      collection: '',        // selected lead_subject_primary_role
      // category is no longer used as a free-text filter
      category: '',          // (you can delete this later if you like)

      availableCities: [],       // NEW: distinct values from `area`
      availableCollections: [],  // collections for the chosen city

      candidatePlaques: [],
      activeTour: [],
      selectedForRemoval: new Set(),
      isAutoPlay: false,
      playedPlaques: new Set(),
      currentStopIndex: 0,          // index of the next stop we care about
      unlockedStops: new Set(),     // ids that are allowed to play audio
      nearlyThereStopId: null,      // current “you’re almost there” popup target
      userLocation: null,
      watchId: null,
      bioCache: {},
      isPlanned: false,
      startHint: '',
      allPlaques: [],         // NEW: cache of everything from Collections.json
      currentSpeechPlaqueId: null,
      isSpeechPlaying: false,
      isSpeechPaused: false,
      currentStopIndex: 0,     // which stop is "next" on the tour
      toast: null,             // small confirmation message (e.g. after skipping)
      tourDistanceMiles: 0,
      tourWalkMinutes: 0,
      tourTotalMinutes: 0,
      tourPrice: 0,
      activeTourMeta: {
        id: null,       // id in localStorage, if any
        isPaid: false,  // has this exact tour been paid for?
      },
      // NEW: planning-stage “mark for replacement” selection
      planningMarkedForReplace: new Set(),
      justNavigated: false,
    };

    // --- Services: Geo ---
    const Geo = {
      calculateDistance: (lat1, lon1, lat2, lon2) => {
        const toRad = (value) => (value * Math.PI) / 180;
        const R = 3958.8; // Miles
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.sin(dLon / 2) * Math.sin(dLon / 2) *
          Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2));
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      },

      getCurrentPosition: () => {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) reject('Geolocation not supported');
          else
            navigator.geolocation.getCurrentPosition(
              (pos) =>
                resolve({
                  latitude: pos.coords.latitude,
                  longitude: pos.coords.longitude,
                }),
              (err) => reject(err)
            );
        });
      },

      optimizeRoute: (startLoc, plaques) => {
        if (plaques.length <= 2) return plaques;

        const hasAllCoords = plaques.every(
          (p) => Number.isFinite(p.latitude) && Number.isFinite(p.longitude)
        );
        if (!hasAllCoords) return plaques;

        // 1. Nearest neighbour
        const pool = [...plaques];
        const route = [];
        let current = { latitude: startLoc.latitude, longitude: startLoc.longitude };

        while (pool.length > 0) {
          let nearestIdx = -1;
          let minDist = Infinity;
          for (let i = 0; i < pool.length; i++) {
            const dist = Geo.calculateDistance(
              current.latitude,
              current.longitude,
              pool[i].latitude,
              pool[i].longitude
            );
            if (dist < minDist) {
              minDist = dist;
              nearestIdx = i;
            }
          }
          const next = pool[nearestIdx];
          route.push(next);
          current = { latitude: next.latitude, longitude: next.longitude };
          pool.splice(nearestIdx, 1);
        }

        // 2. 2-opt
        const totalRouteDistance = (r) => {
          let sum = 0;
          let prev = { latitude: startLoc.latitude, longitude: startLoc.longitude };
          for (const p of r) {
            sum += Geo.calculateDistance(
              prev.latitude,
              prev.longitude,
              p.latitude,
              p.longitude
            );
            prev = p;
          }
          return sum;
        };

        const twoOptSwap = (r, i, k) => [
          ...r.slice(0, i),
          ...r.slice(i, k + 1).reverse(),
          ...r.slice(k + 1),
        ];

        let improved = true;
        let bestRoute = route;
        let bestDistance = totalRouteDistance(bestRoute);

        while (improved) {
          improved = false;
          for (let i = 0; i < bestRoute.length - 1; i++) {
            for (let k = i + 1; k < bestRoute.length; k++) {
              const newRoute = twoOptSwap(bestRoute, i, k);
              const newDistance = totalRouteDistance(newRoute);
              if (newDistance + 1e-9 < bestDistance) {
                bestRoute = newRoute;
                bestDistance = newDistance;
                improved = true;
              }
            }
          }
        }

        return bestRoute;
      },

      generateMapsPreviewUrl: (plaques) => {
        if (!plaques.length) return '';

        const baseUrl = "https://www.google.com/maps/dir/?api=1";

        const getLoc = (p) => {
          const hasCoords =
            Number.isFinite(p.latitude) && Number.isFinite(p.longitude);

          if (hasCoords) {
            return `${p.latitude},${p.longitude}`;
          }
          return encodeURIComponent((p.address || '').trim());
        };

        const dest = getLoc(plaques[plaques.length - 1]);

        let origin = '';
        let waypointPlaques = [];

        if (state.locationMethod === 'MANUAL') {
          origin = getLoc(plaques[0]);          // planned start
          waypointPlaques = plaques.slice(1, -1);
        } else {
          if (state.userLocation) {
            origin = `${state.userLocation.latitude},${state.userLocation.longitude}`;
          }
          waypointPlaques = plaques.slice(0, -1);
        }

        const waypoints = waypointPlaques.map(p => getLoc(p)).join('|');

        let url = `${baseUrl}&destination=${dest}&travelmode=walking`;
        if (origin) url += `&origin=${origin}`;
        if (waypoints) url += `&waypoints=${waypoints}`;

        return url;
      },

      generateMapsNavUrl: (plaques) => {
        if (!plaques.length) return '';

        const baseUrl = "https://www.google.com/maps/dir/?api=1";

        const getLoc = (p) => {
          const hasCoords =
            Number.isFinite(p.latitude) && Number.isFinite(p.longitude);

          if (hasCoords) {
            return `${p.latitude},${p.longitude}`;
          }
          return encodeURIComponent((p.address || '').trim());
        };

        const dest = getLoc(plaques[plaques.length - 1]);
        const waypointPlaques = plaques.slice(0, -1);
        const waypoints = waypointPlaques.map(p => getLoc(p)).join('|');

        let url = `${baseUrl}&destination=${dest}&travelmode=walking`;
        if (waypoints) url += `&waypoints=${waypoints}`;

        return url;
      },

      // find densest cluster of plaques within a radius
      findBestCluster: (plaques, radiusMiles) => {
        const points = plaques.filter(p =>
          Number.isFinite(p.latitude) && Number.isFinite(p.longitude)
        );

        if (!points.length) {
          return { center: null, members: [] };
        }

        let bestIndex = 0;
        let bestCount = 1;

        for (let i = 0; i < points.length; i++) {
          const pivot = points[i];
          let count = 0;

          for (let j = 0; j < points.length; j++) {
            const other = points[j];
            const dist = Geo.calculateDistance(
              pivot.latitude,
              pivot.longitude,
              other.latitude,
              other.longitude
            );
            if (dist <= radiusMiles) count++;
          }

          if (count > bestCount) {
            bestCount = count;
            bestIndex = i;
          }
        }

        const centerPlaque = points[bestIndex];
        const center = {
          latitude: centerPlaque.latitude,
          longitude: centerPlaque.longitude
        };

        const members = points.filter(p =>
          Geo.calculateDistance(
            center.latitude,
            center.longitude,
            p.latitude,
            p.longitude
          ) <= radiusMiles
        );

        return { center, members };
      },

      computeTourStats: (startLoc, plaques) => {
        let distance = 0;
        let prev = { latitude: startLoc.latitude, longitude: startLoc.longitude };

        for (const p of plaques) {
          if (Number.isFinite(p.latitude) && Number.isFinite(p.longitude)) {
            distance += Geo.calculateDistance(
              prev.latitude,
              prev.longitude,
              p.latitude,
              p.longitude
            );
            prev = { latitude: p.latitude, longitude: p.longitude };
          }
        }

        const walkingMinutes = distance * 20; // ~3 mph
        return { distanceMiles: distance, walkingMinutes };
      }
    };

    // --- Speech synthesis voice selection ---
    let preferredVoice = null;

    function choosePreferredVoice() {
      if (!('speechSynthesis' in window)) return null;
      const voices = window.speechSynthesis.getVoices();
      if (!voices || !voices.length) return null;

      // 1. Try an explicitly "UK English Female" style voice name
      const explicitUkFemale = voices.find(v =>
        /UK English Female/i.test(v.name)
      );

      // 2. Any en-GB voice whose name looks like it might be female
      const enGbFemale = voices.find(v =>
        v.lang === 'en-GB' && /female|woman|girl/i.test(v.name)
      );

      // 3. Any en-GB voice
      const enGb = voices.find(v => v.lang === 'en-GB');

      // 4. Any English voice
      const anyEnglish = voices.find(v => v.lang && v.lang.startsWith('en'));

      return explicitUkFemale || enGbFemale || enGb || anyEnglish || voices[0];
    }

    function initVoiceSupport() {
      if (!('speechSynthesis' in window)) return;

      const assign = () => {
        preferredVoice = choosePreferredVoice();
        // console.log('Chosen voice:', preferredVoice);
      };

      // Try immediately
      assign();

      // Some browsers load voices async
      window.speechSynthesis.onvoiceschanged = assign;
    }

    // --- Services: API ---
    const Api = {
      fetchPlaques: async (url) => {
        const res = await fetch(url);
        const data = await res.json();

        return data.map((item, idx) => ({
          id: String(item.id ?? `plaque-${idx}`),
          title: item.title || 'Unknown Title',

          // Collection / role
          category: item.lead_subject_primary_role || item.category || '',

          // City / area
          area: item.area || '',

          latitude: parseFloat(item.latitude),
          longitude: parseFloat(item.longitude),
          address: item.address || '',

          // summary text shown on screen
          summary:
            item.inscription ||
            item.subjects ||
            item.summary ||
            item.description ||
            'No description available.',

          // long-form bio text – audio only
          bio: item.lead_subject_bio || ''
        }));
      },

      geocode: async (query) => {
        const res = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
            query
          )}&limit=1`
        );
        const data = await res.json();
        if (data && data.length) {
          return {
            latitude: parseFloat(data[0].lat),
            longitude: parseFloat(data[0].lon),
          };
        }
        throw new Error('Location not found');
      },

      // reverse geocoding for startHint / display text
      reverseGeocode: async (loc) => {
        const { latitude, longitude } = loc;

        const res = await fetch(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=16&addressdetails=1`
        );
        const data = await res.json();

        if (data && data.display_name) {
          return data.display_name;
        }

        if (data && data.address) {
          const { road, suburb, city, town, village, state, postcode } = data.address;
          const line = [road, suburb || city || town || village, state, postcode]
            .filter(Boolean)
            .join(', ');
          if (line) return line;
        }

        // Fallback to raw coords if nothing nicer
        return `${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
      }
    };
    // --- Icons (SVG Strings) ---
    const Icons = {
      Refresh: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" /></svg>`,
      Speaker: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg>`,
      SpeakerWave: (animate) => `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 ${animate ? 'animate-pulse' : ''}"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6 6 0 0 0 6-6v-1.5m-6 7.5a6 6 0 0 1-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5" /></svg>`,
      MapPin: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4"><path stroke-linecap="round" stroke-linejoin="round" d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z" /></svg>`,
      Heart: (filled) => `<svg xmlns="http://www.w3.org/2000/svg" fill="${filled ? 'currentColor' : 'none'}" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12Z" /></svg>`,
      Trash: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>`,
      ArrowLeft: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18" /></svg>`,
      Play: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4"><path fill-rule="evenodd" d="M4.5 5.653c0-1.426 1.529-2.33 2.779-1.643l11.54 6.348c1.295.712 1.295 2.573 0 3.285L7.28 19.991c-1.25.687-2.779-.217-2.779-1.643V5.653Z" clip-rule="evenodd" /></svg>`,
      Flag: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4"><path fill-rule="evenodd" d="M3 2.25a.75.75 0 0 1 .75.75v.54l1.838-.46a9.75 9.75 0 0 1 6.725.738l.108.054a8.25 8.25 0 0 0 5.58.652l3.109-.732a.75.75 0 0 1 .917.81 47.784 47.784 0 0 0 .005 10.337.75.75 0 0 1-.574.812l-3.114.733a9.75 9.75 0 0 1-6.594-.158l-.108-.054a8.25 8.25 0 0 0-5.69-.625l-2.202.55V21a.75.75 0 0 1-1.5 0V3A.75.75 0 0 1 3 2.25Z" clip-rule="evenodd" /></svg>`,

      HomeTab: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="1.5"
                            class="w-5 h-5">
                          <path stroke-linecap="round" stroke-linejoin="round"
                                d="M2.25 12l9.193-8.308a.75.75 0 0 1 1.014 0L21.75 12M4.5 10.5v9.75A1.5 1.5 0 0 0 6 21.75h12a1.5 1.5 0 0 0 1.5-1.5v-9.75" />
                       </svg>`,

      GuideTab: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                             fill="none" stroke="currentColor" stroke-width="1.5"
                             class="w-5 h-5">
                           <path stroke-linecap="round" stroke-linejoin="round"
                                 d="M4.5 5.25A2.25 2.25 0 0 1 6.75 3h10.5A2.25 2.25 0 0 1 19.5 5.25v13.5L15 16.5l-4.5 2.25L6 16.5l-1.5 2.25z" />
                       </svg>`,

      ColoursTab: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                               fill="none" stroke="currentColor" stroke-width="1.5"
                               class="w-5 h-5">
                             <path stroke-linecap="round" stroke-linejoin="round"
                                   d="M15.75 3.75a6.75 6.75 0 0 1 0 13.5h-1.086a1.5 1.5 0 0 0-1.06.44l-2.707 2.707A.75.75 0 0 1 9 19.69v-2.44a1.5 1.5 0 0 0-1.5-1.5A4.5 4.5 0 0 1 3 11.25 7.5 7.5 0 0 1 10.5 3.75h5.25z" />
                       </svg>`,

      FavsTab: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="1.5"
                            class="w-5 h-5">
                          <path stroke-linecap="round" stroke-linejoin="round"
                                d="M11.48 3.499a.75.75 0 0 1 1.04 0l2.122 2.122 3.004.437a.75.75 0 0 1 .416 1.28l-2.173 2.119.513 3a.75.75 0 0 1-1.088.791L12 12.97l-2.714 1.427a.75.75 0 0 1-1.088-.79l.513-3-2.173-2.12a.75.75 0 0 1 .416-1.279l3.004-.437z" />
                       </svg>`,

      Pause: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                          fill="currentColor" class="w-4 h-4">
                        <path d="M6.75 5.25h2.5a.75.75 0 0 1 .75.75v12a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1-.75-.75v-12a.75.75 0 0 1 .75-.75zm8 0h2.5a.75.75 0 0 1 .75.75v12a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1-.75-.75v-12a.75.75 0 0 1 .75-.75z" />
                    </svg>`,

      Stop: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                          fill="currentColor" class="w-4 h-4">
                        <path d="M6.75 5.25h10.5a1.5 1.5 0 0 1 1.5 1.5v10.5a1.5 1.5 0 0 1-1.5 1.5H6.75a1.5 1.5 0 0 1-1.5-1.5V6.75a1.5 1.5 0 0 1 1.5-1.5z" />
                    </svg>`,

      PadlockLocked: `
                    <svg xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="1.5"
                    class="w-4 h-4">
                    <path stroke-linecap="round" stroke-linejoin="round"
                     d="M16.5 10.5V7a4.5 4.5 0 10-9 0v3.5M7.5 10.5h9A1.5 1.5 0 0118 12v6a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 016 18v-6a1.5 1.5 0 011.5-1.5z" />
                    </svg>
                    `,

      PadlockUnlocked: `
                    <svg xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="1.5"
                    class="w-4 h-4">
                    <path stroke-linecap="round" stroke-linejoin="round"
                    d="M8.25 10.5V7a3.75 3.75 0 017.5 0M7.5 10.5h9A1.5 1.5 0 0118 12v6a1.5 1.5 0 01-1.5 1.5h-9A1.5 1.5 0 016 18v-6a1.5 1.5 0 011.5-1.5z" />
                    </svg>
                    `,
    };

    // --- Application Controller ---
    const app = {
      init: () => {
        initVoiceSupport();
        app.loadCategories();
        app.render();
      },

      // Generic view setter (we'll use this for the bottom nav later)
      setView: (view) => {
        state.view = view;
        state.justNavigated = true;
        app.stopAudioWatch();
      app.render();
      },

      // View Switchers
      goHome: () => {
        state.view = 'HOME';
        state.justNavigated = true;
        state.activeTour = [];
        state.selectedForRemoval = new Set();
        state.currentStopIndex = 0;
        app.stopAudioWatch();
      app.render();
    },


      goFavorites: () => {
  state.view = 'FAVORITES';
  state.justNavigated = true;
  app.stopAudioWatch();
  app.render();
},
      
goToPaidTour: () => {
  app.markTourPaidAndSave();
  state.view = 'INFO';   // new info/safety screen
  state.justNavigated = true;
  app.render();
},

startTourAndOpenMaps: () => {
  if (!state.activeTour || !state.activeTour.length) return;

  if (!state.unlockedStops) state.unlockedStops = new Set();
  state.nearPromptedStopId = null;
  state.arrivalPromptedStopId = null;

  // We’re starting the proper tour now – always from the first stop
  state.currentStopIndex = 0;
  state.isAutoPlay = true;

  // Switch UI into TOUR view *before* opening Google Maps
  state.view = 'TOUR';
  state.justNavigated = true;
  app.render();
  window.scrollTo(0, 0);

  // Now build the route from the beginning of the tour
  const navStops = state.activeTour;
  const navUrl = Geo.generateMapsNavUrl(navStops);

  // Start background location watching for near/arrival prompts
  app.startAudioWatch();

  // Finally hand off to Google Maps
  if (navUrl) {
    window.open(navUrl, '_blank');
  }
},
      
      markTourPaidAndSave: () => {
        if (!state.activeTour.length) return;

        const cityName =
          state.selectedCity || (CITIES[state.cityIndex]?.name || 'Tour');

        const existing = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

        let id = state.activeTourMeta && state.activeTourMeta.id;

        // Prepare a default tour name if we need to create a new entry
        const defaultName = state.isPlanned
          ? `${cityName} – ${state.startHint || 'planned walk'}`
          : `${cityName} walk`;

        // If this tour already exists in favourites, update that record
        if (id) {
          const idx = existing.findIndex((t) => t.id === id);
          if (idx !== -1) {
            existing[idx] = {
              ...existing[idx],
              cityName,
              plaques: state.activeTour,
              isPlanned: state.isPlanned,
              startHint: state.startHint,
              distanceMiles: state.tourDistanceMiles,
              walkMinutes: state.tourWalkMinutes,
              totalMinutes: state.tourTotalMinutes,
              price: state.tourPrice,
              isPaid: true,
            };
          } else {
            // If somehow the id isn’t in storage, fall back to creating a new entry
            id = null;
          }
        }

        // If there is no existing entry, create one automatically
        if (!id) {
          id = Date.now().toString();
          const tour = {
            id,
            name: defaultName,
            date: new Date().toISOString(),
            cityName,
            plaques: state.activeTour,
            isPlanned: state.isPlanned,
            startHint: state.startHint,
            distanceMiles: state.tourDistanceMiles,
            walkMinutes: state.tourWalkMinutes,
            totalMinutes: state.tourTotalMinutes,
            price: state.tourPrice,
            isPaid: true,
          };
          existing.unshift(tour);
        }

        state.activeTourMeta = { id, isPaid: true };

        localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));
      },

      // Update State Actions
      setMethod: (method) => { state.locationMethod = method; app.render(); },
      setAddress: (val) => { state.manualAddress = val; },
      setRadius: (val) => { state.radius = parseFloat(val); document.getElementById('radius-val').innerText = val + ' mi'; },
      setStops: (val) => { state.stops = parseInt(val); document.getElementById('stops-val').innerText = val; },

      setCityFilter: (cityName) => {
        state.selectedCity = cityName;

        const plaques = state.allPlaques || [];
        const collectionsSet = new Set(
          plaques
            .filter(p => !cityName || p.area === cityName)
            .map(p => p.category)
            .filter(c => c && c.trim())
        );
        state.availableCollections = Array.from(collectionsSet).sort();

        // If the previously selected collection doesn’t exist for this city,
        // default to the first one.
        if (!state.availableCollections.includes(state.collection)) {
          state.collection = state.availableCollections[0] || '';
        }
        app.render();
      },

      setCollection: (val) => {
        state.collection = val;
        app.render();
      },

                  getCurrentStopIndex: () => {
                return state.currentStopIndex || 0;
            },

            getRemainingStops: () => {
                if (!state.activeTour || !state.activeTour.length) return [];
                const idx = state.currentStopIndex || 0;
                const start = Math.min(idx, state.activeTour.length);
                return state.activeTour.slice(start);
            },

            showToast: (message) => {
                state.toast = message;
                app.render();
                setTimeout(() => {
                    if (state.toast === message) {
                        state.toast = null;
                        app.render();
                    }
                }, 2000);
            },


      // ----------------------------
      // PLANNING-STAGE KEEP/REPLACE
      // ----------------------------

      togglePlanningReplace: (id, checked) => {
  if (checked) {
    state.planningMarkedForReplace.add(id);
  } else {
    state.planningMarkedForReplace.delete(id);
  }
  app.render();
},

      resetPlanningSelection: () => {
        state.planningMarkedForReplace = new Set();
        app.render();
      },

      applyPlanningChanges: () => {
        const idsToReplace = Array.from(state.planningMarkedForReplace).map(String);
        if (!idsToReplace.length) {
          alert('You haven’t selected any stops to replace on this tour.');
          return;
        }

        if (!state.activeTour.length || !state.candidatePlaques.length) {
          alert('There is no active tour to modify yet.');
          return;
        }

        const removedSet = new Set(idsToReplace);

        // 1) Keep all non-selected stops
        const kept = state.activeTour.filter(
          p => !removedSet.has(String(p.id))
        );

        // 2) Build a pool of possible replacements:
        //    - must be in candidatePlaques
        //    - must NOT already be kept
        //    - must NOT be one of the removed ones
        const keptIds = new Set(kept.map(p => String(p.id)));
        const pool = state.candidatePlaques.filter(p => {
          const id = String(p.id);
          return !keptIds.has(id) && !removedSet.has(id);
        });

        const desired = state.stops;             // what user asked for via slider
        let needed = desired - kept.length;      // how many new ones we ideally want

        if (needed <= 0) {
          // They’re removing more than or equal to the “desired” count,
          // so we will inevitably shorten the tour.
          const shortenOk = confirm(
            `Removing these stops will shorten your tour from ${desired} to ${kept.length} stops.\n\n` +
            `Press OK to continue with a shorter tour, or Cancel to go back and adjust your selection.`
          );
          if (!shortenOk) return;

          // No replacements – just keep the remaining ones
          let newTour = kept;
          if (state.userLocation && newTour.length > 1) {
            newTour = Geo.optimizeRoute(state.userLocation, newTour);
          }
          state.activeTour = newTour;
          state.stops = newTour.length;
          state.planningMarkedForReplace = new Set();
          app.render();
          return;
        }

        // Case: enough replacements available
        if (pool.length >= needed) {
          const replacements = pool
            .slice()                     // copy
            .sort(() => 0.5 - Math.random())
            .slice(0, needed);

          let newTour = [...kept, ...replacements];
          if (state.userLocation && newTour.length > 1) {
            newTour = Geo.optimizeRoute(state.userLocation, newTour);
          }

          state.activeTour = newTour;
          // tour size stays at the user’s requested value
          state.planningMarkedForReplace = new Set();
          app.render();
          return;
        }

        // Case: NOT enough replacements – this is the scenario you described:
        // "I can replace 2 of the 3 stops…"
        const canReplace = pool.length;

        if (canReplace === 0) {
          alert(
            'There are no additional nearby places available to replace the selected stops.\n\n' +
            'Try reducing the number you want to replace or increasing your radius.'
          );
          return;
        }

        const newSize = kept.length + canReplace;
        const ok = confirm(
          `You asked to replace ${idsToReplace.length} stops, ` +
          `but I can only find ${canReplace} alternative locations nearby.\n\n` +
          `Press OK to shorten your tour to ${newSize} stops, ` +
          `or Cancel to go back and adjust which stops you want to replace.`
        );

        if (!ok) return;

        const replacements = pool
          .slice()
          .sort(() => 0.5 - Math.random())
          .slice(0, canReplace);

        let newTour = [...kept, ...replacements];
        if (state.userLocation && newTour.length > 1) {
          newTour = Geo.optimizeRoute(state.userLocation, newTour);
        }

        state.activeTour = newTour;
        state.stops = newTour.length;       // update slider to the new reality
        state.planningMarkedForReplace = new Set();
        app.render();
      },

// ------------------
// AUDIO LOGIC
// ------------------
speak: async (plaqueId) => {
  const plaque = state.activeTour.find(p => p.id === plaqueId);
  if (!plaque) return;

  if (!('speechSynthesis' in window)) {
    alert('Spoken audio is not supported on this device/browser.');
    return;
  }

  // Ensure the unlocked set exists
  if (!state.unlockedStops) {
    state.unlockedStops = new Set();
  }

  // --- Location gate: stop couch-surfing ---
  // Only enforce GPS / distance if this stop has NOT yet been unlocked.
  if (!state.unlockedStops.has(plaqueId)) {
    let loc;
    try {
      // Fresh position each time
      loc = await Geo.getCurrentPosition();
      state.userLocation = loc;
    } catch (err) {
      alert(
        "To hear this stop, you'll need to allow location access on your device " +
        "and listen while you’re actually at the stop."
      );
      return;
    }

    const hasCoords =
      Number.isFinite(plaque.latitude) && Number.isFinite(plaque.longitude);

    if (hasCoords) {
      const dist = Geo.calculateDistance(
        loc.latitude,
        loc.longitude,
        plaque.latitude,
        plaque.longitude
      );

      if (dist > AUDIO_UNLOCK_DISTANCE) {
        alert(
          "Sorry, this audio can only be played when you are physically at this stop.\n\n" +
          "Walk to the stop, then try again."
        );
        return;
      }
    }

    // You’re close enough – mark as unlocked from now on
    state.unlockedStops.add(plaqueId);
  }

  // --- Actual speech logic ---
  window.speechSynthesis.cancel();

  const baseText = `${plaque.title}. ${plaque.bio || plaque.summary || ''}`;
  const text = baseText.trim();
  if (!text) {
    alert('No description available to read for this place of interest.');
    return;
  }

  const utterance = new SpeechSynthesisUtterance(text);

  if (preferredVoice) {
    utterance.voice = preferredVoice;
    utterance.lang = preferredVoice.lang || 'en-GB';
  } else {
    utterance.lang = 'en-GB';
  }

  utterance.rate = 0.95;
  utterance.pitch = 1.0;
  utterance.volume = 1.0;

  utterance.onstart = () => {
    state.currentSpeechPlaqueId = plaqueId;
    state.isSpeechPlaying = true;
    state.isSpeechPaused = false;
    app.render();
  };

  utterance.onend = () => {
    state.isSpeechPlaying = false;
    state.isSpeechPaused = false;
    state.currentSpeechPlaqueId = null;
    app.render();
  };

  utterance.onerror = (e) => {
    console.error('Speech error', e);
    state.isSpeechPlaying = false;
    state.isSpeechPaused = false;
    state.currentSpeechPlaqueId = null;
    app.render();
  };

  window.speechSynthesis.speak(utterance);
},



      pauseSpeech: () => {
        if (!('speechSynthesis' in window)) return;
        window.speechSynthesis.pause();
        state.isSpeechPlaying = false;
        state.isSpeechPaused = true;
        app.render();
      },

      resumeSpeech: () => {
        if (!('speechSynthesis' in window)) return;
        window.speechSynthesis.resume();
        state.isSpeechPlaying = true;
        state.isSpeechPaused = false;
        app.render();
      },

      stopSpeech: () => {
        if (!('speechSynthesis' in window)) return;
        window.speechSynthesis.cancel();
        state.isSpeechPlaying = false;
        state.isSpeechPaused = false;
        state.currentSpeechPlaqueId = null;
        app.render();
      },

      toggleAutoPlay: () => {
        state.isAutoPlay = !state.isAutoPlay;
        if (state.isAutoPlay) app.startAudioWatch();
        else app.stopAudioWatch();
        app.render();
      },

      startAudioWatch: () => {
  if (!navigator.geolocation) return;

  app.stopAudioWatch();

  if (!state.unlockedStops) state.unlockedStops = new Set();
  if (!state.nearPromptedStopId) state.nearPromptedStopId = null;
  if (!state.arrivalPromptedStopId) state.arrivalPromptedStopId = null;

  state.watchId = navigator.geolocation.watchPosition(
    (pos) => {
      const uLat = pos.coords.latitude;
      const uLng = pos.coords.longitude;
      state.userLocation = { latitude: uLat, longitude: uLng };

      if (!state.activeTour.length) return;

      const nextIndex = state.activeTour.findIndex(
        (p) => !state.unlockedStops.has(p.id)
      );

      if (nextIndex === -1) {
        app.stopAudioWatch();
        return;
      }

      state.currentStopIndex = nextIndex;
      const nextStop = state.activeTour[nextIndex];

      if (
        !Number.isFinite(nextStop.latitude) ||
        !Number.isFinite(nextStop.longitude)
      ) {
        return;
      }

      const dist = Geo.calculateDistance(
        uLat,
        uLng,
        nextStop.latitude,
        nextStop.longitude
      );

      // 1) "You’re here" cue – very close (~5m)
      if (dist <= ARRIVAL_DISTANCE_MILES) {
        state.unlockedStops.add(nextStop.id);
        state.nearlyThereStopId = nextStop.id;

        if (state.arrivalPromptedStopId !== nextStop.id) {
          state.arrivalPromptedStopId = nextStop.id;
          app.playArrivalPrompt(nextStop);
        }

        app.render();
        return; // don’t also fire the "approaching" cue this tick
      }

      // 2) "You’re approaching" cue – within main unlock radius
      if (
        dist <= AUDIO_UNLOCK_DISTANCE &&
        !state.unlockedStops.has(nextStop.id)
      ) {
        state.unlockedStops.add(nextStop.id);
        state.nearlyThereStopId = nextStop.id;

        if (state.nearPromptedStopId !== nextStop.id) {
          state.nearPromptedStopId = nextStop.id;
          app.playNearStopPrompt(nextStop);
        }

        app.render();
      }
    },
    (err) => console.error(err),
    { enableHighAccuracy: true }
  );
},

      stopAudioWatch: () => {
        if (state.watchId !== null) {
          navigator.geolocation.clearWatch(state.watchId);
          state.watchId = null;
        }
      },

      // Short spoken “you’re nearly there” nudge
      // Short spoken “you’re nearly there” nudge
playNearStopPrompt: (plaque) => {
  if (!('speechSynthesis' in window)) return;
  if (state.isSpeechPlaying) return;

  try {
    const text = `
      You are approaching your next stop, ${plaque.title}.
      Slow down and get yourself into position in front of the building.
    `;

    const u = new SpeechSynthesisUtterance(text.trim());
    if (preferredVoice) {
      u.voice = preferredVoice;
      u.lang = preferredVoice.lang || 'en-GB';
    } else {
      u.lang = 'en-GB';
    }
    u.rate = 1.0;
    u.pitch = 1.0;
    u.volume = 0.9;

    window.speechSynthesis.speak(u);
  } catch (e) {
    console.warn('Near-stop prompt failed', e);
  }
},

      // Short spoken “you've arrived” nudge (very close)
playArrivalPrompt: (plaque) => {
  if (!('speechSynthesis' in window)) return;
  if (state.isSpeechPlaying) return;

  try {
    const text = `
      You are now at ${plaque.title}.
      When it’s safe to do so, switch back to Curated Tours and tap Listen to hear the story.
    `;

    const u = new SpeechSynthesisUtterance(text.trim());
    if (preferredVoice) {
      u.voice = preferredVoice;
      u.lang = preferredVoice.lang || 'en-GB';
    } else {
      u.lang = 'en-GB';
    }
    u.rate = 1.0;
    u.pitch = 1.0;
    u.volume = 0.9;

    window.speechSynthesis.speak(u);
  } catch (e) {
    console.warn('Arrival prompt failed', e);
  }
},

      goBackOneStop: () => {
  if (!state.activeTour || !state.activeTour.length) return;

  const current = state.currentStopIndex || 0;
  if (current <= 0) return;

  // Step back one stop and reset any audio
  app.stopSpeech();
  state.currentStopIndex = current - 1;
  app.showToast('Back to the previous stop.');
  app.render();
},

stopTourAndSaveProgress: () => {
  if (!state.activeTour || !state.activeTour.length) return;

  const existing = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
  let id = state.activeTourMeta && state.activeTourMeta.id;

  // If the tour hasn’t been saved yet, fall back to the normal save flow
  if (!id) {
    app.saveTour();
    return;
  }

  const idx = existing.findIndex(t => t.id === id);
  if (idx === -1) {
    app.saveTour();
    return;
  }

  // Remember where the user got to
  existing[idx].lastVisitedIndex = state.currentStopIndex || 0;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));

  app.stopSpeech();
  app.stopAudioWatch();

  app.showToast('Tour progress saved. You can resume it from Saved.');
  state.view = 'FAVORITES';
  app.render();
},

  advanceToNextFromStop: (plaqueId, toastMessage, reopenMaps) => {
  if (!state.activeTour || !state.activeTour.length) return;

  const idx = state.activeTour.findIndex(p => p.id === plaqueId);
  if (idx === -1) return;

  const isCurrentAudio = state.currentSpeechPlaqueId === plaqueId;
  if (isCurrentAudio) {
    app.stopSpeech();
  }

  const nextIndex = idx + 1;
  let openMaps = reopenMaps;

  if (nextIndex >= state.activeTour.length) {
    // No more stops; we've effectively finished the tour
    state.currentStopIndex = state.activeTour.length;
    app.showToast('You’ve reached the final stop on this Curated Tour.');
    openMaps = false; // don’t reopen directions once the tour is done
  } else {
    const current = state.currentStopIndex || 0;
    if (nextIndex > current) {
      state.currentStopIndex = nextIndex;
    }
    if (toastMessage) {
      app.showToast(toastMessage);
    }
  }

  if (openMaps) {
    const remainingStops = app.getRemainingStops();
    const navStops = remainingStops.length ? remainingStops : state.activeTour;
    const navUrl = Geo.generateMapsNavUrl(navStops);
    if (navUrl) window.open(navUrl, '_blank');
  }
    state.justNavigated = true;
    app.render();
  },

skipStop: (plaqueId) => {
  if (!state.activeTour || !state.activeTour.length) return;

  const ok = confirm(
    'Skip this stop and move on to the next? I’ll update your walking directions in Google Maps.'
  );
  if (!ok) return;

  app.advanceToNextFromStop(plaqueId, 'Skipping this stop.', true);
},

continueToNext: (plaqueId) => {
  app.advanceToNextFromStop(plaqueId, 'Okay, moving on to the next stop.', true);
},

      // Logic: Load Collections (and feed autocomplete)
      loadCategories: async () => {
        const cityCfg = CITIES[state.cityIndex]; // still just the Collections.json entry

        try {
          const plaques = await Api.fetchPlaques(cityCfg.url);
          state.allPlaques = plaques;

          // 1) Build city list from `area`
          const citySet = new Set(
            plaques
              .map(p => p.area)
              .filter(a => a && a.trim())
          );
          state.availableCities = Array.from(citySet).sort();

          // Default city if none chosen yet
          if (!state.selectedCity && state.availableCities.length) {
            state.selectedCity = state.availableCities[0];
          }

          // 2) Build collections list for the selected city
          const collectionsSet = new Set(
            plaques
              .filter(p => !state.selectedCity || p.area === state.selectedCity)
              .map(p => p.category)
              .filter(c => c && c.trim())
          );
          state.availableCollections = Array.from(collectionsSet).sort();

          // Default collection if none chosen yet
          if (!state.collection && state.availableCollections.length) {
            state.collection = state.availableCollections[0];
          }

          if (state.view === 'HOME') app.render();
        } catch (e) {
          console.error(e);
        }
      },

      goBackOneStop: () => {
  if (!state.activeTour || !state.activeTour.length) return;

  const idx = state.currentStopIndex || 0;
  if (idx <= 0) return; // already at first stop

  // Stop any audio
  app.stopSpeech();

  const newIndex = idx - 1;
  const plaque = state.activeTour[newIndex];
  if (!plaque) return;

  state.currentStopIndex = newIndex;
  app.showToast('Back to the previous stop.');
  app.render();

  // Scroll card into view after re-render
  setTimeout(() => {
    const el = document.getElementById(`card-${plaque.id}`);
    if (el) {
      el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }, 50);
},

stopTourAndSaveProgress: () => {
  if (!state.activeTour || !state.activeTour.length) return;

  const existing = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

  // Make sure we have a tour id (should already be set for paid tours)
  let id = state.activeTourMeta && state.activeTourMeta.id;
  const isPaid = !!(state.activeTourMeta && state.activeTourMeta.isPaid);

  const cityName =
    state.selectedCity || (CITIES[state.cityIndex]?.name || 'Tour');

  if (!id) {
    // Fallback: create a new saved tour if somehow not already saved
    id = Date.now().toString();
    existing.unshift({
      id,
      name: `${cityName} walk`,
      date: new Date().toISOString(),
      cityName,
      plaques: state.activeTour,
      isPlanned: state.isPlanned,
      startHint: state.startHint,
      distanceMiles: state.tourDistanceMiles,
      walkMinutes: state.tourWalkMinutes,
      totalMinutes: state.tourTotalMinutes,
      price: state.tourPrice,
      isPaid,
      lastVisitedIndex: state.currentStopIndex || 0,
    });
  } else {
    const idx = existing.findIndex(t => t.id === id);
    if (idx !== -1) {
      existing[idx] = {
        ...existing[idx],
        plaques: state.activeTour,
        isPlanned: state.isPlanned,
        startHint: state.startHint,
        distanceMiles: state.tourDistanceMiles,
        walkMinutes: state.tourWalkMinutes,
        totalMinutes: state.tourTotalMinutes,
        price: state.tourPrice,
        isPaid,
        lastVisitedIndex: state.currentStopIndex || 0,
        date: new Date().toISOString(),
      };
    }
  }

  localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));
  app.showToast('Progress saved – you can resume this tour later.');
  state.view = 'FAVORITES';
  app.render();
},

      generateTour: async (e) => {
  if (e) e.preventDefault();
  state.loading = true;
  state.error = null;
  app.render();

  const cityCfg = CITIES[state.cityIndex];

  try {
    // 1. Base plaque set: city + collection
    const all = state.allPlaques && state.allPlaques.length
      ? state.allPlaques
      : await Api.fetchPlaques(cityCfg.url);

    let filtered = all;

    // City filter
    if (state.selectedCity) {
      const cityName = state.selectedCity.toLowerCase();
      filtered = filtered.filter(p =>
        p.area && p.area.toLowerCase() === cityName
      );
    }

    // Collection filter
    if (state.collection) {
      const col = state.collection.toLowerCase();
      filtered = filtered.filter(p =>
        p.category && p.category.toLowerCase() === col
      );
    }

    if (!filtered.length) {
      throw new Error('No places of interest found for this city / collection.');
    }

    // ALWAYS: plan mode – find best cluster in the city
    const { center, members } = Geo.findBestCluster(filtered, state.radius);

    if (!center || !members.length) {
      throw new Error(
        `No suitable cluster found within ${state.radius} miles for this collection.`
      );
    }

    const startLoc = center;
    state.userLocation = startLoc;
    let nearby = members;
    state.isPlanned = true;

    if (!nearby.length) {
      throw new Error(`No places of interest found within ${state.radius} miles.`);
    }

    // 2. Select & optimise tour
    const shuffled = [...nearby].sort(() => 0.5 - Math.random());
    let selected = shuffled.slice(0, state.stops);
    selected = Geo.optimizeRoute(startLoc, selected);

    // 3. Update state for this tour
    state.candidatePlaques = nearby;
    state.activeTour = selected;
    state.selectedForRemoval = new Set();
    state.playedPlaques = new Set();
    state.activeTourMeta = {
      id: null,
      isPaid: false,
    };

    // planning-stage replace flags + navigation state
    state.planningMarkedForReplace = new Set();
    state.currentStopIndex = 0;
    state.unlockedStops = new Set();
    state.nearlyThereStopId = null;

    // 4. Compute a friendly startHint
    try {
      const suggestedAddress = await Api.reverseGeocode(startLoc);
      state.startHint = suggestedAddress;
    } catch (err) {
      console.warn('Reverse geocoding failed, falling back', err);
      state.startHint = cityCfg.exampleAddress || state.selectedCity || '';
    }

    // 5. Compute tour stats & price for the preview
    const stats = Geo.computeTourStats(startLoc, selected);
    state.tourDistanceMiles = stats.distanceMiles;
    state.tourWalkMinutes = stats.walkingMinutes;

    const dwellMinutes = state.activeTour.length * 5;
    state.tourTotalMinutes = Math.round(stats.walkingMinutes + dwellMinutes);

    const rawPrice = PRICE_BASE + PRICE_PER_STOP * state.activeTour.length;
    state.tourPrice = Math.round(rawPrice * 100) / 100;

    // 6. Show preview/paywall
    state.view = 'PREVIEW';
    state.justNavigated = true;
  } catch (err) {
    state.error = err.message || 'Error generating tour';
  } finally {
    state.loading = false;
    app.render();
  }
},
      // Logic: Regenerate (Swap)
      toggleRemove: (id, checked) => {
        // Once a tour is paid, do not allow editing
        if (state.activeTourMeta && state.activeTourMeta.isPaid) return;

        if (checked) state.selectedForRemoval.add(id);
        else state.selectedForRemoval.delete(id);

        // Update checkbox visually without full re-render for speed
        const el = document.getElementById(`lbl-${id}`);
        if (el) {
          el.className = `text-xs font-bold uppercase ${checked ? 'text-red-600' : 'text-gray-400 group-hover:text-gray-600'
            }`;
        }
        const txt = document.getElementById(`txt-${id}`);
        if (txt) txt.innerText = checked ? 'Remove' : 'Keep';
        const card = document.getElementById(`card-${id}`);
        if (card) {
          card.className =
            `bg-white rounded-xl shadow-md overflow-hidden border-l-4 mb-4 ` +
            `relative group transition-all ${checked ? 'border-red-500 bg-red-50' : 'border-plaque-blue'
            }`;
        }

        app.updateActionBar();
      },
      regenerateSelected: () => {
        // No regenerating on paid tours
        if (state.activeTourMeta && state.activeTourMeta.isPaid) return;

        const idsToRemove = Array.from(state.selectedForRemoval).map(String);
        if (!idsToRemove.length) return;

        const removedSet = new Set(idsToRemove);
        const kept = state.activeTour.filter(p => !removedSet.has(String(p.id)));

        const keptIds = new Set(kept.map(p => String(p.id)));
        const pool = state.candidatePlaques.filter(
          p => !keptIds.has(String(p.id)) && !removedSet.has(String(p.id))
        );

        const needed = state.stops - kept.length;

        if (needed > 0 && pool.length < needed) {
          alert(
            'Not enough alternative locations nearby to replace all selected places of interest. ' +
            'Try reducing the number selected or increasing your radius.'
          );
          return;
        }

        const replacements = pool.sort(() => 0.5 - Math.random()).slice(0, needed);
        let newTour = [...kept, ...replacements];

        if (state.userLocation) {
          newTour = Geo.optimizeRoute(state.userLocation, newTour);
        }

        state.activeTour = newTour;
        state.selectedForRemoval = new Set();
        app.render();
      },
      removeSelectedNoReplacement: () => {
        // No removing stops on paid tours
        if (state.activeTourMeta && state.activeTourMeta.isPaid) return;

        const idsToRemove = Array.from(state.selectedForRemoval).map(String);
        if (!idsToRemove.length) return;

        const removedSet = new Set(idsToRemove);
        let newTour = state.activeTour.filter(p => !removedSet.has(String(p.id)));

        state.stops = newTour.length;

        if (state.userLocation && newTour.length > 1) {
          newTour = Geo.optimizeRoute(state.userLocation, newTour);
        }

        state.activeTour = newTour;
        state.selectedForRemoval = new Set();
        app.render();
      },

      // Logic: Favorites
      saveTour: () => {
        if (!state.activeTour.length) return;

        const cityName =
          state.selectedCity || (CITIES[state.cityIndex]?.name || 'Tour');

        const existing = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

        let id = state.activeTourMeta && state.activeTourMeta.id;
        const isPaid = !!(state.activeTourMeta && state.activeTourMeta.isPaid);

        // If this tour hasn’t been saved before, create a new id
        if (!id) {
          id = Date.now().toString();
        }

        const defaultName = state.isPlanned
          ? `${cityName} – ${state.startHint || 'planned walk'}`
          : `${cityName} walk`;

        const name = (prompt('Give this tour a name:', defaultName) || defaultName).trim();

        const tourData = {
          id,
          name,
          date: new Date().toISOString(),
          cityName,
          plaques: state.activeTour,
          isPlanned: state.isPlanned,
          startHint: state.startHint,
          distanceMiles: state.tourDistanceMiles,
          walkMinutes: state.tourWalkMinutes,
          totalMinutes: state.tourTotalMinutes,
          price: state.tourPrice,
          isPaid,
        };

        const idx = existing.findIndex((t) => t.id === id);
        if (idx === -1) {
          existing.unshift(tourData);
        } else {
          existing[idx] = tourData;
        }

        state.activeTourMeta = { id, isPaid };

        localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));
        alert('Tour saved!');
      },

      loadTour: (id) => {
        const existing = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        const tour = existing.find((t) => t.id === id);
        if (!tour) return;

        state.activeTour = tour.plaques || [];
        state.candidatePlaques = []; // can’t regenerate well from saved
        state.stops = tour.plaques ? tour.plaques.length : 0;

        state.isPlanned = !!tour.isPlanned;
        state.startHint = tour.startHint || '';
        state.selectedCity = tour.cityName || state.selectedCity;

        state.tourDistanceMiles = tour.distanceMiles || 0;
        state.tourWalkMinutes = tour.walkMinutes || 0;
        state.tourTotalMinutes = tour.totalMinutes || 0;
        state.tourPrice = tour.price || 0;

        state.activeTourMeta = {
          id: tour.id,
          isPaid: !!tour.isPaid,
        };

        state.currentStopIndex = 0;

        // NEW: reset on-foot navigation state for this loaded tour
        state.unlockedStops = new Set();
        state.currentStopIndex = 0;
        state.nearlyThereStopId = null;

        // IMPORTANT: Only jump straight into the full tour if it’s paid
        state.view = tour.isPaid ? 'TOUR' : 'PREVIEW';
        state.justNavigated = true;

        app.render();
      },
      deleteTour: (id, e) => {
        e.stopPropagation();
        const existing = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        const updated = existing.filter(t => t.id !== id);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
        app.render();
      },

      // --- Render Functions ---

updateActionBar: () => {
  const bar = document.getElementById('action-bar');
  if (!bar) return;

  const isPaidTour = !!(state.activeTourMeta && state.activeTourMeta.isPaid);
  const isManualPlanningContext =
    state.view === 'TOUR' && state.locationMethod === 'MANUAL';

  // On a PAID live tour, we don’t need extra buttons – Maps is already running,
  // and the tour has been auto-saved.
  if (isPaidTour) {
    state.selectedForRemoval = new Set();
    bar.innerHTML = '';
    return;
  }

  // Use only the remaining stops from the current index onwards
  const remainingStops = app.getRemainingStops();
  const navStops = remainingStops.length ? remainingStops : state.activeTour;

  const navUrl = Geo.generateMapsNavUrl(navStops);
  const previewUrl = isManualPlanningContext
    ? Geo.generateMapsPreviewUrl(navStops)
    : null;

  const previewButtonHtml = previewUrl
    ? `
      <a
        href="${previewUrl}"
        target="_blank"
        class="w-full bg-white border border-gray-300 text-gray-700 hover:bg-gray-50
               font-bold py-3 rounded-xl flex items-center justify-center gap-2
               shadow-sm transition-colors"
      >
        ${Icons.MapPin} Preview route near planned start
      </a>
    `
    : '';

  // If the tour is paid, **no regenerate / remove controls**, just navigation + save
  if (isPaidTour) {
    state.selectedForRemoval = new Set(); // clear any stale selection
    bar.innerHTML = `
      <div class="max-w-md mx-auto w-full space-y-2">
        <a
          href="${navUrl}"
          target="_blank"
          class="w-full bg-blue-100 hover:bg-blue-200 text-plaque-blue
                 font-bold py-3 rounded-xl flex items-center justify-center gap-2
                 shadow-sm transition-colors"
        >
          ${Icons.MapPin} Start in Google Maps
        </a>
        ${previewButtonHtml}
        <button
          onclick="app.saveTour()"
          class="w-full bg-green-600 hover:bg-green-700 text-white font-bold
                 py-3 rounded-xl flex items-center justify-center gap-2
                 shadow-md transition-colors"
        >
          ${Icons.Heart(true)} Save to Favorites
        </button>
      </div>
    `;
    return;
  }

  const count = state.selectedForRemoval.size;
  const canSwap = state.candidatePlaques.length > state.activeTour.length;

  if (count > 0) {
    // Some cards are selected → show regenerate / remove controls
    bar.innerHTML = `
      <div class="max-w-md mx-auto w-full space-y-2">
        <button
          onclick="app.regenerateSelected()"
          ${!canSwap ? 'disabled' : ''}
          class="w-full bg-red-600 ${canSwap ? 'animate-bounce-short' : ''} hover:bg-red-700 text-white font-bold py-3 rounded-xl flex items-center justify-center gap-2 shadow-md transition-colors disabled:opacity-60"
        >
          ${Icons.Refresh} Regenerate ${count} Selected
        </button>
        ${
          !canSwap
            ? '<p class="text-xs text-red-500 text-center">No alternative places of interest nearby to swap in.</p>'
            : ''
        }
        <button
          onclick="app.removeSelectedNoReplacement()"
          class="w-full bg-white border border-red-500 text-red-600 font-bold py-3 rounded-xl flex items-center justify-center gap-2 shadow-sm transition-colors"
        >
          ${Icons.Trash} Remove Selected from Tour
        </button>
      </div>
    `;
  } else {
    // No cards selected – map + save controls, still using navStops
    bar.innerHTML = `
      <div class="max-w-md mx-auto w-full space-y-2">
        <a
          href="${navUrl}"
          target="_blank"
          class="w-full bg-blue-100 hover:bg-blue-200 text-plaque-blue font-bold py-3 rounded-xl flex items-center justify-center gap-2 shadow-sm transition-colors"
        >
          ${Icons.MapPin} Start in Google Maps
        </a>
        ${previewButtonHtml}
        <button
          onclick="app.saveTour()"
          class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-xl flex items-center justify-center gap-2 shadow-md transition-colors"
        >
          ${Icons.Heart(true)} Save to Favorites
        </button>
      </div>
    `;
  }
},

      render: () => {
  const root = document.getElementById('app');
  let html = '';

  if (state.toast) {
    html += `
      <div class="fixed top-16 left-0 right-0 z-40 flex justify-center pointer-events-none">
        <div class="bg-gray-900 text-white text-xs px-3 py-2 rounded-full shadow-md pointer-events-auto">
          ${state.toast}
        </div>
      </div>`;
  }

  if (state.error) {
    html += `
      <div class="mb-6 mt-4 bg-red-50 border-l-4 border-red-500 p-4 rounded-r-lg">
        <div class="flex">
          <div class="ml-3">
            <p class="text-sm text-red-700">${state.error}</p>
          </div>
        </div>
      </div>`;
  }

  if (state.view === 'HOME') {
    html += app.renderHome();
  } else if (state.view === 'PREVIEW') {
    html += app.renderPreview();
  } else if (state.view === 'INFO') {
    html += app.renderStartInfo();
  } else if (state.view === 'TOUR') {
    html += app.renderTour();
  } else if (state.view === 'FAVORITES') {
    html += app.renderFavorites();
  } else if (state.view === 'GUIDE') {
    html += app.renderGuide();
  } else if (state.view === 'COLOURS') {
    html += app.renderColours();
  }

  root.innerHTML = html;

// After a view change, snap to top once
if (state.justNavigated) {
  window.scrollTo(0, 0);
  state.justNavigated = false;
}

if (state.view === 'TOUR') {
  // Ensure Maps + Save action bar is rendered
  app.updateActionBar();
}

// Always refresh bottom navigation
app.renderNav();
},

  renderStartInfo: () => {
  const cityName = state.selectedCity || (CITIES[state.cityIndex]?.name || 'Tour');
  const stopCount = state.activeTour ? state.activeTour.length : 0;

  return `
    <div class="pb-24">
      <div class="max-w-md mx-auto bg-white rounded-2xl shadow-xl border border-gray-100 p-6 space-y-4 mt-4">
        <h1 class="text-xl font-extrabold text-gray-900 mb-1">
          Before you start your Curated Tour
        </h1>
        <p class="text-xs text-gray-500 tracking-wide uppercase mb-2">
          ${cityName} · ${stopCount} stops
        </p>

        <p class="text-sm text-gray-700">
          This Curated Tour has already been
          <span class="font-semibold">added to your Saved tours</span>.
          If the app closes or your phone goes to sleep, you can reopen it
          any time from the <span class="font-semibold">Saved</span> tab.
        </p>

        <p class="text-sm text-gray-700">
          This is an <span class="font-semibold">audio walking tour</span>. To get the most from it:
        </p>

        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
          <li>
            Make sure your phone isn’t muted and your volume is set to a comfortable level.
          </li>
          <li>
            In busy areas, <span class="font-semibold">earbuds or headphones</span> help – but always stay
            aware of traffic and your surroundings.
          </li>
          <li>
            Your tour will open in <span class="font-semibold">Google Maps</span>. Use Maps to walk towards
            each stop, then switch back to Curated Tours once you’ve arrived.
          </li>
          <li>
            Check the card in Curated Tours to confirm the <span class="font-semibold">address and description</span>
            of the building or site you should be looking at.
          </li>
          <li>
            Curated Tours will give on-foot <span class="font-semibold">audio cues</span> as you approach each stop
            and again when you are right outside. This happens automatically in the background
            while your tour is running.
          </li>
          <li>
            Some stops may be <span class="font-semibold">private homes or workplaces</span>. Please be respectful –
            often viewing from the opposite pavement is better than standing in a doorway.
          </li>
          <li>
            After each story, tap <span class="font-semibold">“Continue to next stop”</span>.
            If you need to miss a stop, use <span class="font-semibold">“Skip this stop”</span>.
            In both cases I’ll regenerate your walking directions in Google Maps to the next stop.
          </li>
        </ul>

        <div class="pt-2">
          <button
            onclick="app.startTourAndOpenMaps()"
            class="w-full bg-plaque-blue hover:bg-blue-900 text-white font-bold py-3 rounded-xl shadow-md transition-colors flex items-center justify-center gap-2"
          >
            Got it – let’s go!
          </button>

          <button
            onclick="app.goHome()"
            class="w-full text-xs text-gray-500 mt-3 hover:underline text-center"
          >
            Cancel and start again
          </button>
        </div>
      </div>
    </div>
  `;
},

      renderNav: () => {
        const nav = document.getElementById('bottom-nav');
        if (!nav) return;

        // Treat TOUR as part of the "New tour" tab for highlighting
        const logicalView =
          state.view === 'TOUR' ? 'HOME' : state.view;

        const tabClass = (view) =>
          'flex flex-col items-center flex-1 py-2 text-xs font-medium transition-colors ' +
          (logicalView === view
            ? 'text-plaque-blue'
            : 'text-gray-400');

        nav.innerHTML = `
                    <div class="max-w-2xl mx-auto px-4">
                        <div class="flex justify-between items-center">
                            <button onclick="app.setView('HOME')" class="${tabClass('HOME')}">
                                <span class="mb-1">${Icons.HomeTab}</span>
                                <span>New tour</span>
                            </button>
                            <button onclick="app.setView('GUIDE')" class="${tabClass('GUIDE')}">
                                <span class="mb-1">${Icons.GuideTab}</span>
                                <span>Guide</span>
                            </button>
                            <button onclick="app.setView('COLOURS')" class="${tabClass('COLOURS')}">
                                <span class="mb-1">${Icons.ColoursTab}</span>
                                <span>Plaques</span>
                            </button>
                            <button onclick="app.setView('FAVORITES')" class="${tabClass('FAVORITES')}">
                                <span class="mb-1">${Icons.FavsTab}</span>
                                <span>Saved</span>
                            </button>
                        </div>
                    </div>
                `;
      },

      renderHome: () => {
  return `
    <div class="w-full max-w-md mx-auto bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100 mt-0">
      <form onsubmit="app.generateTour(event)" class="p-6 space-y-6">

        <!-- 1. City -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">Select City</label>
          <select
            onchange="app.setCityFilter(this.value)"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-plaque-blue bg-white"
          >
            ${
              state.availableCities.length
                ? state.availableCities
                    .map(city => `<option value="${city}" ${city === state.selectedCity ? 'selected' : ''}>${city}</option>`)
                    .join('')
                : '<option disabled>Loading cities…</option>'
            }
          </select>
        </div>

        <!-- 2. Collection for that city -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Select Collection
          </label>
          <select
            onchange="app.setCollection(this.value)"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-plaque-blue bg-white"
          >
            ${
              state.availableCollections.length
                ? state.availableCollections
                    .map(c => `<option value="${c}" ${c === state.collection ? 'selected' : ''}>${c}</option>`)
                    .join('')
                : '<option disabled>Select a city first…</option>'
            }
          </select>
        </div>

        <!-- 3. Radius / stops sliders -->
        <div class="flex gap-4">
          <div class="flex-1">
            <div class="flex justify-between items-center mb-2">
              <label class="text-sm font-medium text-gray-700">Radius</label>
              <span id="radius-val" class="text-sm font-bold text-plaque-blue">${state.radius} mi</span>
            </div>
            <input
              type="range"
              min="0.2"
              max="5"
              step="0.1"
              value="${state.radius}"
              oninput="app.setRadius(this.value)"
              class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-plaque-blue"
            >
          </div>
          <div class="flex-1">
            <div class="flex justify-between items-center mb-2">
              <label class="text-sm font-medium text-gray-700">Stops</label>
              <span id="stops-val" class="text-sm font-bold text-plaque-blue">${state.stops}</span>
            </div>
            <input
              type="range"
              min="1"
              max="${MAX_TOUR_SIZE}"
              step="1"
              value="${state.stops}"
              oninput="app.setStops(this.value)"
              class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-plaque-blue"
            >
          </div>
        </div>

        <!-- 4. Generate -->
        <button
          type="submit"
          ${state.loading ? 'disabled' : ''}
          class="w-full bg-plaque-blue hover:bg-blue-900 text-white font-bold py-4 rounded-xl shadow-lg transition disabled:opacity-70 flex justify-center items-center"
        >
          ${state.loading ? 'Planning your tour…' : 'Begin planning your Curated Tour'}
        </button>

        <p class="mt-2 text-xs text-gray-500 text-center">
          I’ll build a walkable route for this city and collection. You can
          <span class="font-semibold">start it straight away</span> or
          <span class="font-semibold">save it to your Saved tours</span>
          to use later.
        </p>
      </form>
    </div>

  `;
},

      renderPreview: () => {
        const cityName = state.selectedCity || (CITIES[state.cityIndex]?.name || 'Tour');
        const stopCount = state.activeTour.length;
        const radius = state.radius;
        const distanceMiles = state.tourDistanceMiles || 0;
        const distanceStr = distanceMiles < 0.1
          ? '< 0.1'
          : distanceMiles.toFixed(1);
        const totalMinutes = state.tourTotalMinutes || 0;
        const hours = Math.floor(totalMinutes / 60);
        const mins = totalMinutes % 60;
        const timeStr = hours
          ? `${hours} hr ${mins} min`
          : `${mins} min`;
        const startLabel = state.isPlanned
          ? (state.startHint || 'the suggested starting area')
          : 'your current location';
        const alphaStops = [...state.activeTour]
          .slice()
          .sort((a, b) => (a.title || '').localeCompare(b.title || ''));
        const hasMarkedForReplace = state.planningMarkedForReplace.size > 0;

        return `
    <div class="pb-28">
      <div class="max-w-md mx-auto bg-white rounded-2xl shadow-xl border border-gray-100 p-6 space-y-4 mt-4">
        <h1 class="text-xl font-extrabold text-gray-900 mb-1">
          Your Curated Tour of ${cityName}
        </h1>
     
        <p class="text-sm text-gray-700">
          Thank you for considering <span class="font-semibold">Curated Tours</span> as your walking tour guide.
        </p>

        <p class="text-sm text-gray-700">
          Based on <span class="font-semibold">${startLabel}</span> and a search radius of
          <span class="font-semibold">${radius.toFixed(1)} miles</span>,
          I’ve identified <span class="font-semibold">${stopCount}</span>
          stops that match your chosen collection.
        </p>

        ${stopCount > 0
            ? `
        <!-- Planning summary: choose stops to replace -->
        <div class="mt-4">
          <h2 class="text-sm font-semibold text-gray-900 mb-1">
            The places we’ll visit on this Curated Tour are listed below.
          </h2>
          <p class="text-xs text-gray-500 mb-3">
            Please feel free to review this list and tick any stops you’d like me to swap for alternatives nearby.
            Just check the box next to any place you’re less interested in, and I’ll look for a better fit before you pay.
          </p>

          <div class="space-y-1">
            ${alphaStops.map(p => `
                <label
  class="flex items-start gap-3 px-2 py-2 rounded-lg cursor-pointer
         ${state.planningMarkedForReplace.has(p.id)
           ? 'bg-red-50 border border-red-200'
           : 'hover:bg-gray-50'}">
                  <input
                    type="checkbox"
                    class="mt-1 w-4 h-4 text-red-600 border-gray-300 rounded focus:ring-red-500"
                    onchange="app.togglePlanningReplace('${p.id}', this.checked)"
                    ${state.planningMarkedForReplace.has(p.id) ? 'checked' : ''}
                  >
                  <div class="flex-1">
                    <div class="flex justify-between items-baseline">
                      <span class="text-sm font-semibold text-gray-900">
                        ${p.title}
                      </span>
                    </div>
                    ${p.summary
                ? `<p class="text-xs text-gray-600 mt-0.5 break-words">${p.summary}</p>`
                : ''
              }
                  </div>
                </label>
              `).join('')
            }
          </div>

          <p class="mt-3 text-xs text-gray-500">
  Tick one or more stops above that you’d like me to swap out.
  When you’re ready, use the button at the bottom of the screen to replace them.
</p>
        </div>
        `
            : ''
          }

        <!-- Distance / time summary -->
        <div class="mt-6 grid grid-cols-2 gap-3 text-sm">
          <div class="bg-blue-50 border border-blue-100 rounded-xl p-3">
            <p class="text-xs font-semibold text-plaque-blue uppercase tracking-wide">
              Approx. distance
            </p>
            <p class="mt-1 text-lg font-bold text-gray-900">
              ${distanceStr} miles
            </p>
          </div>
          <div class="bg-blue-50 border border-blue-100 rounded-xl p-3">
            <p class="text-xs font-semibold text-plaque-blue uppercase tracking-wide">
              Approx. duration
            </p>
            <p class="mt-1 text-lg font-bold text-gray-900">
              ${timeStr}
            </p>
            <p class="mt-1 text-[0.7rem] text-gray-600">
              Includes walking time and about 5 minutes at each stop.
            </p>
          </div>
        </div>

        <!-- Price -->
        <div class="mt-4 bg-yellow-50 border border-yellow-200 rounded-xl p-3">
          <p class="text-xs font-semibold text-yellow-800 uppercase tracking-wide">
            Tour price
          </p>
          <p class="mt-1 text-2xl font-extrabold text-gray-900">
            £${state.tourPrice.toFixed(2)}
          </p>
          <p class="mt-1 text-xs text-gray-600">
            One-off payment for this Curated Tour on your device.
          </p>
        </div>

<!-- Actions -->
<div class="mt-5 space-y-2">
  ${
    hasMarkedForReplace
      ? `
        <button
          type="button"
          onclick="app.applyPlanningChanges()"
          class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-xl shadow-md transition-colors flex items-center justify-center gap-2"
        >
          Replace selected stops
        </button>
        <p class="text-xs text-gray-500 text-center">
          Once you’re happy with the line-up, you’ll see the payment and “start tour” options here.
        </p>
      `
      : `
        <button
          onclick="app.goToPaidTour()"
          class="w-full bg-plaque-blue hover:bg-blue-900 text-white font-bold py-3 rounded-xl shadow-md transition-colors flex items-center justify-center gap-2"
        >
          Let’s get going
        </button>

        <button
          onclick="app.saveTour()"
          class="w-full bg-white border border-gray-300 text-gray-800 font-semibold py-3 rounded-xl shadow-sm transition-colors hover:bg-gray-50 flex items-center justify-center gap-2"
        >
          ${Icons.Heart(false)}
          Save this Curated Tour for later
        </button>

        <button
          onclick="app.goHome()"
          class="w-full text-xs text-gray-500 mt-1 hover:underline"
        >
          Cancel and start again
        </button>
      `
  }
</div>
      </div>
    </div>
  `;
      },

     renderNearStopBanner: () => {
  if (!state.nearlyThereStopId) return '';

  const plaque = state.activeTour.find(
    (p) => p.id === state.nearlyThereStopId
  );
  if (!plaque) return '';

  return `
    <div class="fixed inset-x-0 bottom-20 z-30 flex justify-center px-4">
      <div class="max-w-md w-full bg-yellow-50 border border-yellow-400 rounded-2xl shadow-2xl p-4 max-h-[50vh] overflow-y-auto">
        <p class="text-xs font-semibold text-yellow-800 uppercase tracking-wide mb-1">
          Upcoming stop
        </p>
        <h2 class="text-lg font-bold text-gray-900 mb-2">
          ${plaque.title}
        </h2>
        <p class="text-sm text-gray-800 mb-2">
          You’re very close to this stop. Slow down and get yourself into a safe,
          comfortable position in front of the building.
        </p>
        <p class="text-xs text-gray-700 mb-3">
          Some stops may be private homes or workplaces. Please be respectful –
          sometimes viewing from the opposite pavement is better than standing
          directly in someone’s doorway.
        </p>
        <button
          type="button"
          onclick="app.confirmArrivedAtStop('${plaque.id}')"
          class="w-full inline-flex items-center justify-center px-4 py-2.5 rounded-full bg-plaque-blue text-white text-sm font-semibold shadow-sm hover:bg-blue-900 transition-colors"
        >
          I’m here – show this stop
        </button>
      </div>
    </div>
  `;
},

      renderTour: () => {
  const cityName = state.selectedCity || (CITIES[state.cityIndex]?.name || 'Tour');
  const isPaidTour = !!(state.activeTourMeta && state.activeTourMeta.isPaid);

  const startNote =
    !isPaidTour && state.isPlanned
      ? `
      <div class="mb-4 bg-blue-50 border-l-4 border-plaque-blue p-3 rounded-r-lg text-xs text-gray-800">
        <p class="font-semibold mb-1">Suggested starting area</p>
        <p>
          This tour has been centred on a cluster of places for this collection.
          Begin your walk near
          <span class="font-semibold">${state.startHint || 'the suggested starting point'}</span>,
          then follow the stops in order.
        </p>
      </div>
    `
      : '';

  const nearStopBanner = app.renderNearStopBanner();

  const total = state.activeTour.length;
  let currentCardHtml = '';

  if (!total) {
    currentCardHtml = `
      <p class="text-sm text-gray-500">
        There are no stops on this Curated Tour.
      </p>
    `;
  } else {
    const idx = app.getCurrentStopIndex();
    const safeIndex = Math.min(Math.max(idx, 0), total - 1);
    const plaque = state.activeTour[safeIndex];
    currentCardHtml = app.renderCard(plaque, safeIndex, total);
  }

  return `
    <div class="pb-32">
      <div class="flex items-center justify-center mb-4">
        <div class="text-center">
          <h2 class="text-lg font-bold text-gray-900">${cityName} Tour</h2>
          <p class="text-xs text-gray-500">${state.activeTour.length} Locations</p>
        </div>
      </div>

      ${startNote}
      ${nearStopBanner}

      <div class="space-y-4">
        ${currentCardHtml}
      </div>

      <div
        id="action-bar"
        class="fixed bottom-16 left-0 right-0 bg-white border-t border-gray-200 p-4
               shadow-[0_-5px_10px_rgba(0,0,0,0.05)] z-10 flex flex-col gap-3"
      >
        <!-- Filled by updateActionBar after render() -->
      </div>
    </div>
  `;
},

renderCard: (plaque, index, total) => {
  const isSel = state.selectedForRemoval.has(plaque.id);
  const isPaidTour = !!(state.activeTourMeta && state.activeTourMeta.isPaid);
  const canEditTour = !isPaidTour;

  // NEW: stable numbering
  const n = plaque.stopNumber || index + 1;
  const isFirst = n === 1;
  const isLast  = n === total;

  let label = `Stop ${n}`;
  let badgeText = n;
  let badgeBg = 'bg-plaque-blue';

  if (isFirst) {
    badgeBg = 'bg-green-600';
    // Optional: if you still want a subtle hint:
    // label = `Stop ${n} · Starting point`;
  } else if (isLast) {
    badgeBg = 'bg-gray-800';
    // Optional: label = `Stop ${n} · Final stop`;
  }

  const isCurrentAudio = state.currentSpeechPlaqueId === plaque.id;
  const isPaused = state.isSpeechPaused && isCurrentAudio;
  const isPlaying = state.isSpeechPlaying && isCurrentAudio;
  const cardBorderClass =
    isSel && canEditTour ? 'border-red-500 bg-red-50' : 'border-plaque-blue';

  const canGoBack = (state.currentStopIndex || 0) > 0;

  return `
    <div id="card-${plaque.id}"
         class="bg-white rounded-xl shadow-md overflow-hidden border-l-4 mb-4
                relative group transition-all ${cardBorderClass}">
      <div class="p-5">
        <div class="flex justify-between items-start mb-2">
          <div class="flex gap-2 items-center">
            <div class="${badgeBg} text-white w-8 h-8 flex items-center justify-center rounded-full font-bold shadow-sm flex-shrink-0">
              ${badgeText}
            </div>
            <div class="flex flex-col">
              <span class="text-xs text-gray-400 font-mono uppercase tracking-wide">
                ${label}
              </span>
              ${
                plaque.category
                  ? `<span class="text-xs text-gray-500 font-bold bg-gray-100 px-2 py-0.5 rounded-full inline-block w-max">
                       ${plaque.category}
                     </span>`
                  : ''
              }
            </div>
          </div>

          ${/* Keep your existing Keep/Remove toggle when editable */''}
          ${canEditTour ? `
            <label class="flex items-center gap-2 cursor-pointer select-none">
              <span id="txt-${plaque.id}"
                    class="text-xs font-bold uppercase ${isSel ? 'text-red-600' : 'text-gray-400 group-hover:text-gray-600'}">
                ${isSel ? 'Remove' : 'Keep'}
              </span>
              <input
                type="checkbox"
                ${isSel ? 'checked' : ''}
                onchange="app.toggleRemove('${plaque.id}', this.checked)"
                class="w-5 h-5 text-red-600 border-gray-300 rounded focus:ring-red-500"
              >
            </label>
          ` : ''}
        </div>

        <h3 class="text-lg font-bold text-gray-900 leading-tight mb-2 mt-2 pr-2">
          ${plaque.title}
        </h3>

        <div class="flex items-start text-gray-500 text-sm mb-3">
          <span class="mr-1 mt-0.5">${Icons.MapPin}</span>
          <span class="font-medium">${plaque.address}</span>
        </div>

        <p class="text-gray-600 text-sm leading-relaxed mb-4">
          ${plaque.summary}
        </p>

        <div class="border-t border-gray-100 pt-3 space-y-3">

          <!-- Listen: primary green full-width button -->
          <button
            onclick="app.speak('${plaque.id}')"
            class="w-full flex items-center justify-center gap-2 py-2.5 px-3
                   bg-green-600 hover:bg-green-700 text-white rounded-lg
                   text-sm font-semibold transition-colors"
          >
            ${Icons.Speaker}
            <span>${isCurrentAudio && isPlaying ? 'Restart audio' : 'Listen'}</span>
          </button>

          <!-- Pause/Resume + Stop audio (only when this card is active) -->
          ${
            isCurrentAudio
              ? `
          <div class="flex flex-wrap gap-2">
            <button
              onclick="app.${isPaused ? 'resumeSpeech' : 'pauseSpeech'}()"
              class="flex items-center justify-center gap-1 py-2 px-3 rounded-lg
                     text-xs font-semibold border border-gray-300 bg-white
                     hover:bg-gray-50"
            >
              ${isPaused ? Icons.Play : Icons.Pause}
              <span>${isPaused ? 'Resume' : 'Pause'}</span>
            </button>
            <button
              onclick="app.stopSpeech()"
              class="flex items-center justify-center gap-1 py-2 px-3 rounded-lg
                     text-xs font-semibold border border-red-400 text-red-600
                     bg-white hover:bg-red-50"
            >
              ${Icons.Stop}
              <span>Stop audio</span>
            </button>
          </div>
          `
              : ''
          }

          <!-- Continue: primary blue full-width button -->
          <button
            type="button"
            onclick="app.continueToNext('${plaque.id}')"
            class="w-full py-2.5 rounded-lg bg-plaque-blue hover:bg-blue-900
                   text-white text-sm font-semibold"
          >
            ${isEnd ? 'Finish tour' : 'Continue to next stop'}
          </button>

          <!-- Back / Skip row + centred Stop button -->
          <div class="flex flex-col items-center gap-2 mt-1">

            <!-- Back + Skip, equal width and centred -->
            <div class="flex gap-2 w-full max-w-xs justify-center">
              ${
                canGoBack
                  ? `
              <button
                type="button"
                onclick="app.goBackOneStop()"
                class="flex-1 px-3 py-2 rounded-lg border border-plaque-blue
                       bg-white text-xs font-semibold text-plaque-blue
                       hover:bg-blue-50"
              >
                Back to previous
              </button>
              `
                  : ''
              }

              <button
                type="button"
                onclick="app.skipStop('${plaque.id}')"
                class="${
                  canGoBack ? 'flex-1' : 'w-full'
                } px-3 py-2 rounded-lg bg-gray-900 text-white text-xs font-semibold
                       hover:bg-black"
              >
                Skip this stop
              </button>
            </div>

            <!-- Stop tour & save progress: same width as row above, centred -->
            <button
              type="button"
              onclick="app.stopTourAndSaveProgress()"
              class="w-full max-w-xs px-4 py-2.5 rounded-lg bg-red-600
                     hover:bg-red-700 text-white text-xs font-semibold
                     shadow-sm"
            >
              Stop tour &amp; save progress
            </button>
          </div>
        </div>
      </div>
    </div>
  `;
},
      renderFavorites: () => {
        const tours = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

        return `
    <div class="h-full">
      <div class="flex items-center mb-6">
        <button onclick="app.goHome()" class="p-2 -ml-2 text-gray-600 hover:text-plaque-blue">
          ${Icons.ArrowLeft}
        </button>
        <h2 class="text-2xl font-bold text-gray-900 ml-2">My Saved Tours</h2>
      </div>

      ${tours.length === 0
            ? `
          <div class="text-center py-20 bg-white rounded-2xl border border-dashed border-gray-300">
            <p class="text-gray-500 mb-4">No saved tours yet.</p>
            <button onclick="app.goHome()" class="text-plaque-blue font-medium hover:underline">
              Create your first tour
            </button>
          </div>
        `
            : `
          <div class="space-y-4">
            ${tours
              .map((tour) => {
                const isPaid = !!tour.isPaid; // old tours default to locked
                const padlockIcon = isPaid ? Icons.PadlockUnlocked : Icons.PadlockLocked;
                const padlockText = isPaid ? 'Unlocked tour' : 'Locked – payment required';
                const padlockColor = isPaid ? 'text-plaque-blue' : 'text-red-500';

                return `
                    <div onclick="app.loadTour('${tour.id}')"
                         class="bg-white p-5 rounded-xl shadow-sm border border-gray-200
                                hover:border-plaque-blue hover:shadow-md transition-all cursor-pointer
                                group relative">
                      <div class="flex justify-between items-start">
                        <div>
                          <h3 class="font-bold text-lg text-gray-800 group-hover:text-plaque-blue">
                            ${tour.name || `${tour.cityName} walk`}
                          </h3>
                          <p class="text-xs text-gray-500 mt-1">
                            ${tour.isPlanned
                    ? `Planned tour – start near: ${tour.startHint || 'chosen address'}`
                    : 'Recorded from your current location'
                  }
                          </p>
                          <p class="text-xs text-gray-400 mt-1">
                            Saved on ${new Date(tour.date).toLocaleDateString()}
                          </p>
                          <div class="mt-3 flex gap-1">
                            ${tour.plaques
                    .slice(0, 3)
                    .map(
                      () =>
                        `<div class="w-2 h-2 rounded-full bg-gray-300 group-hover:bg-plaque-blue"></div>`
                    )
                    .join('')}
                            ${tour.plaques.length > 3
                    ? `<span class="text-xs text-gray-400 ml-1">+${tour.plaques.length - 3}</span>`
                    : ''
                  }
                          </div>
                        </div>

                        <div class="flex flex-col items-end gap-2">
                          <!-- Padlock status -->
                          <div class="flex items-center gap-1 text-xs ${padlockColor}">
                            ${padlockIcon}
                            <span>${padlockText}</span>
                          </div>

                          <!-- Delete button -->
                          <button
                            onclick="app.deleteTour('${tour.id}', event)"
                            class="p-2 text-gray-300 hover:text-red-500 hover:bg-red-50
                                   rounded-full transition-colors z-10"
                          >
                            ${Icons.Trash}
                          </button>
                        </div>
                      </div>
                    </div>
                  `;
              })
              .join('')
            }
          </div>
        `
          }
    </div>
  `;
      },

      confirmArrivedAtStop: (plaqueId) => {
        // Keep this stop unlocked and clear the banner
        state.unlockedStops.add(plaqueId);
        state.nearlyThereStopId = null;
        app.render();

        // After re-render, scroll that card into view
        setTimeout(() => {
          const el = document.getElementById(`card-${plaqueId}`);
          if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 50);
      },

      renderGuide: () => {
        return `
                <div class="max-w-md mx-auto bg-white rounded-2xl shadow-md p-6 space-y-4 mt-4">
                    <h2 class="text-xl font-bold text-gray-900">How Curated Tours works</h2>
                    <p class="text-sm text-gray-700">
                        Curated Tours helps you build short, walkable tours of historic places
                        around a starting point you choose.
                    </p>

                    <h3 class="text-sm font-semibold text-gray-900 mt-3">1. Pick a city</h3>
                    <p class="text-sm text-gray-700">
                       Start by choosing the city you want to explore from the
                       <strong>Select City</strong> dropdown.
                    </p>

                    <h3 class="text-sm font-semibold text-gray-900 mt-3">2. Choose a collection</h3>
                    <p class="text-sm text-gray-700">
                       Then choose a <strong>Collection (Category / Role)</strong> for that city –
                       for example <strong>Britpop</strong>, <strong>Charles Dickens</strong> or
                       any other themed group of locations.
                    </p>

                    <h3 class="text-sm font-semibold text-gray-900 mt-3">3. Choose when you’re walking</h3>
                    <p class="text-sm text-gray-700">
                       <strong>Start now (Use my current location)</strong> is ideal when you are already out
                       in the city and want the tour to begin where you are standing.
                       <br/><br/>
                       <strong>Plan for later (Suggest a good starting area)</strong> is useful when you are
                       planning ahead. Curated Tours will find a tight cluster of places for your chosen
                       collection and recommend a clear starting area.
                    </p>

                    <h3 class="text-sm font-semibold text-gray-900 mt-3">4. Fine-tune your walk</h3>
                    <p class="text-sm text-gray-700">
                        Use the <strong>Radius</strong> slider to decide how far Curated Tours
                        should look for places of interest around your starting point, and
                        <strong>Stops</strong> to choose how many places you’d like to visit.
                    </p>

                    <h3 class="text-sm font-semibold text-gray-900 mt-3">5. Explore and tweak</h3>
                    <p class="text-sm text-gray-700">
                        Tap <strong>Generate Walking Tour</strong> to see your route.
                        You can mark any stop as <strong>Remove</strong> to swap it for
                        another nearby place of interest, or remove it altogether if you want a shorter tour.
                    </p>

                    <h3 class="text-sm font-semibold text-gray-900 mt-3">6. Walk the route</h3>
                    <p class="text-sm text-gray-700">
                       Use the cards to read about each place of interest, tap
                       <strong>Listen</strong> for spoken audio, and use
                       <strong>Start in Google Maps</strong> for turn-by-turn directions from
                       wherever you are. If you planned a tour around an address, you can also
                       use <strong>Preview route near planned start</strong> to see how long
                       the walk looks from that area.
                    </p>
                </div>
                `;
      },

      renderColours: () => {
        return `
                <div class="max-w-md mx-auto bg-white rounded-2xl shadow-md p-6 space-y-4 mt-4">
                    <h2 class="text-xl font-bold text-gray-900">Understanding plaque colours</h2>
                    <p class="text-sm text-gray-700">
                        Different organisations use different coloured plaques to mark
                        people, events and buildings of interest. Colours vary by city, but
                        this rough guide helps you make sense of what you see.
                    </p>

                    <div class="space-y-3 text-sm text-gray-700">
                        <div>
                            <h3 class="font-semibold text-plaque-blue">Blue plaques</h3>
                            <p>
                                Often used for nationally significant figures or events.
                                In London, the classic blue plaque is usually associated
                                with English Heritage.
                            </p>
                        </div>

                        <div>
                            <h3 class="font-semibold text-green-700">Green and other local colours</h3>
                            <p>
                                Many boroughs and local societies use their own colours
                                (green, maroon, brown, black, and others) to celebrate
                                people and stories that matter locally rather than nationally.
                            </p>
                        </div>

                        <div>
                            <h3 class="font-semibold text-gray-900">The details matter most</h3>
                            <p>
                                Regardless of colour, the lettering on the plaque tells you
                                who or what is being commemorated, and usually why that place
                                was chosen – a home, workplace, meeting point or key event.
                            </p>
                        </div>

                        <div>
                            <h3 class="font-semibold text-gray-900">PlaqueLark’s role</h3>
                            <p>
                                PlaqueLark doesn’t change or standardise colours – it simply
                                helps you find interesting plaques nearby and string them
                                together into a walkable story.
                            </p>
                        </div>
                    </div>
                </div>
                `;
      }
    };

    // Initialize App
    app.init();
  </script>
</body>

</html>
